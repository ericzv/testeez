{% extends 'base.html' %}
{% block title %}Sessão de Estudo - Zeta Cards{% endblock %}
{% block head %}
<style>
  /* Estilos existentes */
  .progress-bar-container {
    width: 50%;
    margin: 0 auto 10px auto;
    height: 4px;
    background-color: #e0e0e0;
  }
  .progress-bar-fill {
    height: 100%;
    background-color: #76c7c0;
    transition: width 0.3s ease-in-out;
  }
  .answer-buttons-container {
    margin-top: 20px;
    margin-bottom: 10px;
    text-align: center;
  }
  .answer-btn small {
    display: block;
    font-size: 0.8rem;
  }
  .id-phase-container {
    text-align: left;
    font-size: small;
    color: #888;
    margin-bottom: 10px;
  }
  .id-phase-container a {
    color: #888;
    text-decoration: none;
  }
  .centered-text {
    text-align: center;
  }
  .bottom-buttons {
    display: flex;
    gap: 10px;
    justify-content: center;
    align-items: center;
  }
  .bottom-buttons a {
    width: 200px;
    text-align: center;
    vertical-align: middle;
  }
  .toggle-buttons {
    margin-top: 10px;
    text-align: center;
  }

  /* Novo estilo para a área de conteúdo com altura fixa */
  .card-content-area {
    min-height: 250px; /* Altura mínima fixa - ajustada para 250px */
    display: flex;
    flex-direction: column;
    overflow-y: auto; /* Permite scroll se o conteúdo for maior */
    position: relative;
  }

  /* Estilos para manter as seções de pergunta e resposta com tamanho consistente */
  #question-section, #answer-section {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    padding: 10px 0;
  }

  /* Garantir que o conteúdo da pergunta/resposta seja flexível */
  .card-text-container {
    flex: 1;
    overflow-y: auto;
  }
  
  /* Estilo para os botões de resposta - usa visibility para preservar o espaço */
  #answer-buttons {
    visibility: hidden; /* Inicia invisível mas mantém o espaço */
    margin-top: 20px;
    margin-bottom: 10px;
    text-align: center;
  }
</style>
{% endblock %}
{% block content %}
<div class="progress-bar-container">
  <div class="progress-bar-fill" style="width: {{ progress_percent }}%;"></div>
</div>
<div class="card animated-card">
  <div class="card-body centered-text">
    <!-- Bloco superior: exibe o ID do cartão e a etiqueta de fase -->
    <div class="id-phase-container">
      <a href="{{ url_for('cards.card_detail', card_id=card.id) }}" id="card-link">Cartão #{{ card.id }}</a>
      {% if card.review_count == 0 %}
        <span style="color: blue;">Cartão novo</span>
      {% elif card.next_review <= datetime_module().utcnow() %}
        <span style="color: green;">Cartão a revisar</span>
      {% else %}
        <span style="color: gray;">Cartão em intervalo</span>
      {% endif %}
    </div>
    <h5 class="card-title" style="margin-top: 10px;">Cartão {{ current_index + 1 }} de {{ total }}</h5>
    <p><strong>Revisados:</strong> {{ cards_reviewed }} | <strong>Restantes:</strong> {{ total - cards_reviewed }}</p>
    <hr>
    
    <!-- Área de conteúdo com altura fixa -->
    <div class="card-content-area">
      <!-- Seção da pergunta -->
      <div id="question-section" class="centered-text">
        <h5>Pergunta:</h5>
        <div class="card-text-container">
          <p class="card-text">{{ card.front | process_front | safe }}</p>
        </div>
      </div>
      
      <!-- Seção da resposta, inicialmente oculta -->
      <div id="answer-section" class="centered-text" style="display: none;">
        <h5>Resposta:</h5>
        <div class="card-text-container">
          <p class="card-text">{{ card.back | process_answer | safe }}</p>
        </div>
      </div>
      
      <!-- Botões de resposta (inicialmente invisíveis, mas ocupando espaço) -->
      <div id="answer-buttons" class="answer-buttons-container">
        <form method="POST" action="{{ url_for('cards.study_session') }}">
          <button type="submit" name="response" value="errei" class="btn btn-danger">
            Errei<br><small>{{ next_errei }}</small>
          </button>
          <button type="submit" name="response" value="difícil" class="btn btn-warning">
            Difícil<br><small>{{ next_dificil }}</small>
          </button>
          <button type="submit" name="response" value="facil" class="btn btn-success">
            Fácil<br><small>{{ next_facil }}</small>
          </button>
          <button type="submit" name="response" value="muito_facil" class="btn btn-primary">
            Muito Fácil<br><small>{{ next_muitofacil }}</small>
          </button>
        </form>
      </div>
    </div>
    
    <hr> <!-- A barra horizontal abaixo da área de conteúdo agora fica fixa -->
    
    <!-- Botão de toggle para mostrar/ocultar a resposta -->
    <div class="toggle-buttons">
      <button class="btn btn-info" id="toggle-answer-btn">Mostrar Resposta</button>
    </div>
    
    <!-- Botão "Voltar cartão (Ctrl+Z)" -->
    <div class="toggle-buttons" style="margin-top: 10px;">
      <a href="{{ url_for('cards.undo_review') }}" class="btn btn-dark btn-sm">Voltar cartão (Ctrl+Z)</a>
    </div>
    
    <hr>
    
    <!-- Botões inferiores: Menu da sessão de estudo e Encerrar sessão -->
    <div class="bottom-buttons">
      <a id="menu-btn" href="{{ url_for('cards.study_lobby') }}" class="btn btn-dark btn-sm">
        Menu da sessão de estudo
      </a>
      <a id="end-btn" href="{{ url_for('cards.end_session') }}" class="btn btn-sm btn-secondary">
        Encerrar sessão de estudo
      </a>
    </div>
    
    <!-- Cronômetro -->
    <div class="timer-container" style="width: 100%; text-align: center; margin-top: 15px;">
      <span id="study-timer" style="font-size: 0.75rem; color: rgba(128, 128, 128, 0.2);">0:00</span>
    </div>
    
    <div class="gamification-alerts-container" style="position: fixed; bottom: 20px; left: 0; right: 0; z-index: 1000;">
      {% for category, message in get_flashed_messages(with_categories=true) %}
        {% if category == 'gamification' %}
          <div class="alert alert-gamification text-center" style="max-width: 600px; margin: 0 auto;">{{ message }}</div>
        {% endif %}
      {% endfor %}
    </div>
  </div>
</div>
{% endblock %}
{% block scripts %}
<script>
function areAnswerButtonsVisible() {
    return document.getElementById('answer-buttons').style.display !== 'none';
}
function toggleAnswer() {
    var questionSection = document.getElementById('question-section');
    var answerSection = document.getElementById('answer-section');
    var answerButtons = document.getElementById('answer-buttons');
    var toggleBtn = document.getElementById('toggle-answer-btn');
    
    if (answerSection.style.display === 'none') {
        // Mostrar resposta
        answerSection.style.display = 'flex';
        questionSection.style.display = 'none';
        answerButtons.style.visibility = 'visible'; // Mostrar botões sem alterar o layout
        toggleBtn.textContent = 'Ocultar Resposta';
    } else {
        // Ocultar resposta
        answerSection.style.display = 'none';
        answerButtons.style.visibility = 'hidden'; // Ocultar botões sem alterar o layout
        questionSection.style.display = 'flex';
        toggleBtn.textContent = 'Mostrar Resposta';
    }
    window.scrollTo(0,0);
}
document.getElementById('toggle-answer-btn').addEventListener('click', toggleAnswer);
document.addEventListener('keydown', function(event) {
    if (event.target.tagName.toLowerCase() === 'input' || event.target.tagName.toLowerCase() === 'textarea') {
        return;
    }
    
    // Atalho para mostrar/ocultar resposta (Espaço ou Enter)
    if ((event.code === 'Space' || event.key === 'Enter') && document.getElementById('answer-section').style.display === 'none') {
        event.preventDefault();
        toggleAnswer();
    } 
    // Atalhos para responder (1, 2, 3, 4) - apenas se os botões de resposta estiverem visíveis
    else if (document.getElementById('answer-buttons').style.visibility === 'visible') {
        if (event.key === '1') {
            document.querySelector('button[name="response"][value="errei"]').click();
        } else if (event.key === '2') {
            document.querySelector('button[name="response"][value="difícil"]').click();
        } else if (event.key === '3') {
            document.querySelector('button[name="response"][value="facil"]').click();
        } else if (event.key === '4') {
            document.querySelector('button[name="response"][value="muito_facil"]').click();
        }
    } 
    // Outros atalhos sempre disponíveis
    else if (event.key.toLowerCase() === 'd') {
        window.location = '{{ url_for("cards.card_detail", card_id=card.id) }}';
    } else if (event.ctrlKey && event.key.toLowerCase() === 'z') {
        window.location = '{{ url_for("cards.undo_review") }}';
    }
});
// Adicionar no bloco de script do study_session.html
let timerInterval;
let timerSeconds = 0;
let timerActive = true;

function startTimer() {
  timerSeconds = 0;
  updateTimerDisplay();
  clearInterval(timerInterval);
  
  timerInterval = setInterval(function() {
    if (timerActive) {
      timerSeconds++;
      if (timerSeconds >= 60) {
        // Atingiu 1 minuto, parar o timer
        clearInterval(timerInterval);
      }
      updateTimerDisplay();
    }
  }, 1000);
}

function updateTimerDisplay() {
  const minutes = Math.floor(timerSeconds / 60);
  const seconds = timerSeconds % 60;
  document.getElementById('study-timer').textContent = 
    minutes + ':' + (seconds < 10 ? '0' : '') + seconds;
}

function resetTimer() {
  clearInterval(timerInterval);
  timerSeconds = 0;
  updateTimerDisplay();
}

// Iniciar o timer quando a página carrega
document.addEventListener('DOMContentLoaded', function() {
  startTimer();
  
  // Resetar e iniciar o timer quando o botão de mostrar resposta é clicado
  document.getElementById('toggle-answer-btn').addEventListener('click', function() {
    if (document.getElementById('answer-section').style.display === 'none') {
      // Resetar o timer quando a resposta é mostrada
      // não reiniciamos aqui porque isso acontecerá na próxima carta
    }
  });
  
  // Interceptar o envio do formulário para capturar o tempo gasto
  document.querySelectorAll('button[name="response"]').forEach(function(button) {
    button.addEventListener('click', function() {
      // Apenas adiciona o tempo se for menor que 60 segundos
      if (timerSeconds < 60) {
        // Enviar o tempo para o servidor
        const timeInput = document.createElement('input');
        timeInput.type = 'hidden';
        timeInput.name = 'time_spent';
        timeInput.value = timerSeconds;
        this.closest('form').appendChild(timeInput);
      }
    });
  });
  
  // Quando o usuário clica em "Ver detalhes do cartão", parar o timer
  document.getElementById('card-link').addEventListener('click', function() {
    timerActive = false;
  });
});

// Substitua a função finishStudy e os event listeners
async function finishStudy() {
  try {
    // Tentar fazer a chamada AJAX, mas não impedir a navegação se falhar
    await fetch('/gamification/finish_study', { 
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      }
    });
    console.log("Estudo finalizado com sucesso");
  } catch (err) {
    console.error('Erro ao finalizar estudo, mas continuando navegação:', err);
    // Ignorar o erro e continuar
  }
}

// Intercepta o clique no Menu - versão mais robusta
document.getElementById('menu-btn').addEventListener('click', function(e) {
  e.preventDefault();
  const targetHref = this.getAttribute('href'); // Armazenar o href de forma segura
  
  // Tentar finalizar o estudo, mas garantir navegação mesmo em caso de erro
  finishStudy()
    .catch(err => console.error('Erro ignorado:', err))
    .finally(() => {
      if (targetHref) {
        window.location.href = targetHref;
      } else {
        // Fallback se o href estiver faltando
        window.location.href = '{{ url_for("cards.study_lobby") }}';
      }
    });
});

// Intercepta o clique no Encerrar sessão - versão mais robusta
document.getElementById('end-btn').addEventListener('click', function(e) {
  e.preventDefault();
  const targetHref = this.getAttribute('href'); // Armazenar o href de forma segura
  
  // Tentar finalizar o estudo, mas garantir navegação mesmo em caso de erro
  finishStudy()
    .catch(err => console.error('Erro ignorado:', err))
    .finally(() => {
      if (targetHref) {
        window.location.href = targetHref;
      } else {
        // Fallback se o href estiver faltando
        window.location.href = '{{ url_for("cards.end_session") }}';
      }
    });
});

</script>
{% endblock %}