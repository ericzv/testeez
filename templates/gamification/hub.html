{% extends 'gamification/base.html' %}

{% block extra_css %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/hub.css') }}">
{% endblock %}

{% block game_content %}

<!-- Navega√ß√£o independente do hub -->
<a href="{{ url_for('cards.index') }}" class="nav-button">
  <span>‚Üê</span>
  Voltar ao Retina Cards
</a>

<div id="particles-js"></div>
<!-- HUD de Currencies -->
<div class="currencies-hud" id="currencies-hud">
    <div class="currency-item">
        <img src="{{ url_for('static', filename='game.data/crystal.png') }}" alt="Cristais" class="currency-icon">
        <span class="currency-name">Cristais de Mem√≥ria:</span>
        <span class="currency-value" id="crystals-value">{{ player.crystals }}</span>
    </div>
    <div class="currency-item">
        <img src="{{ url_for('static', filename='game.data/gold.png') }}" alt="Ouro" class="currency-icon">
        <span class="currency-name">Ouro:</span>
        <span class="currency-value" id="gold-value">{{ player.run_gold or 0 }}</span>
    </div>
    <div class="currency-item">
        <img src="{{ url_for('static', filename='game.data/hourglass.png') }}" alt="Ampulhetas" class="currency-icon">
        <span class="currency-name">Ampulhetas Eternas:</span>
        <span class="currency-value" id="hourglasses-value">{{ player.eternal_hourglasses or 0 }}</span>
    </div>
</div>

<!-- Active Run Buffs Section -->
<div class="run-buffs-hud" id="run-buffs-hud" style="display:none;">
    <div class="run-buffs-title">
        <img src="{{ url_for('static', filename='game.data/buffs/memory.png') }}" alt="Lembran√ßas" style="width: 16px; height: 16px; margin-right: 5px;">
        Lembran√ßas Ativas
    </div>
    <div class="run-buffs-list" id="run-buffs-list">
        <!-- Os buffs ser√£o inseridos via JavaScript -->
    </div>
</div>

<!-- HUD de Rel√≠quias -->
<div class="relics-bar" id="relics-bar" style="display:none;">
    <div class="relics-bar-items" id="relics-bar-items">
        <!-- As rel√≠quias ser√£o inseridas via JavaScript -->
    </div>
</div>

<div class="menu-container">

<!-- Bot√µes ao redor - 7 bot√µes com posi√ß√£o de Perfil e Flashcards invertidas -->
<!-- Bot√µes ao redor - 10 bot√µes com posi√ß√£o homog√™nea -->
{% set menu = [
  ('index', 'üìö', 'Flashcards'),
  ('attributes', '‚ú®', 'Atributos'),
  ('game_inventory', 'üéí', 'Invent√°rio'),
  ('items.shop', 'ü™ô', 'Loja'),
  ('bestiary', 'üìò', 'Besti√°rio'), 
  ('battle.battle', '‚öîÔ∏è', 'Batalha'),
  ('game_profile', 'üßô‚Äç‚ôÇÔ∏è', 'Perfil'),
  ('battle.skills', 'üî•', 'Habilidades'),
  ('talents', 'üåü', 'Talentos'),
] %}

<!-- Posicionamento dos bot√µes equidistantes -->

<a href="{{ url_for(menu[1][0]) }}" class="menu-btn btn-1">
  <span class="menu-icon">{{ menu[1][1] }}</span>
  <span class="menu-text">{{ menu[1][2] }}</span>
</a>

<a href="{{ url_for(menu[3][0]) }}" class="menu-btn btn-3">
  <span class="menu-icon">{{ menu[3][1] }}</span>
  <span class="menu-text">{{ menu[3][2] }}</span>
</a>

<a href="#" class="menu-btn btn-5 battle-btn" onclick="goToBattle(event)">
  <span class="menu-icon">{{ menu[5][1] }}</span>
  <span class="menu-text">{{ menu[5][2] }}</span>
</a>

<a href="{{ url_for(menu[6][0]) }}" class="menu-btn btn-6">
  <span class="menu-icon">{{ menu[6][1] }}</span>
  <span class="menu-text">{{ menu[6][2] }}</span>
</a>

<a href="{{ url_for(menu[7][0]) }}" class="menu-btn btn-7">
  <span class="menu-icon">{{ menu[7][1] }}</span>
  <span class="menu-text">{{ menu[7][2] }}</span>
</a>

<a href="{{ url_for('talents.talents') }}" class="menu-btn btn-8">
  <span class="menu-icon">üåü</span>
  <span class="menu-text">Talentos</span>
</a>

<!-- Notification Bell Icon -->
<div class="notification-bell" id="notificationBell">
  <span class="bell-icon">üîî</span>
  <span class="notification-count" id="notificationCount">0</span>
</div>

<!-- Notification Panel (Hidden by default) -->
<div class="notification-panel" id="notificationPanel">
  <div class="notification-header">
    <h3>Notifica√ß√µes</h3>
    <button id="clearNotifications">Limpar Todas</button>
  </div>
  <div class="notification-list" id="notificationList">
    <!-- Notifications will be inserted here via JavaScript -->
  </div>
</div>

</div>

<!-- Memory Selection Popup -->
<div id="memory-selection-popup" class="victory-popup" style="display: none;">
  <div class="victory-content">
      <div class="victory-header">
          <img src="{{ url_for('static', filename='game.data/buffs/memory.png') }}" alt="Lembran√ßas" class="victory-icon">
          <h2>Escolha uma Lembran√ßa</h2>
          <p>Selecione um dos buffs abaixo para sua run atual:</p>
      </div>
      
      <div class="memory-options" id="memory-options-container">
          <!-- As op√ß√µes ser√£o inseridas via JavaScript -->
      </div>
      
      <div class="victory-actions">
          <button id="confirm-memory-btn" class="btn btn-primary" disabled>Confirmar Sele√ß√£o</button>
      </div>
  </div>
</div>

<!-- Relic Selection Popup -->
<div id="relic-selection-popup" class="ui-dialog" style="display: none;">
  <div class="ui-panel relic-selection-modal">
      <div class="victory-header">
          <img src="{{ url_for('static', filename='game.data/relics/relic_icon.png') }}" alt="Rel√≠quia" class="relic-header-icon">
          <h2>Escolha uma Rel√≠quia</h2>
      </div>
      
      <div class="relic-options" id="relic-options-container">
          <!-- As op√ß√µes ser√£o inseridas via JavaScript -->
      </div>

      <!-- Rewrite Divider -->
      <div class="rewrite-divider" id="relic-rewrite-divider" style="display: none;">
          <div class="rewrite-line"></div>
          <div class="rewrite-button" id="relic-rewrite-button">
              <span class="rewrite-cost" id="relic-rewrite-cost">3</span>
              <img src="{{ url_for('static', filename='game.data/hourglass_small.png') }}" alt="Ampulheta Eterna" class="rewrite-icon">
          </div>
          <div class="rewrite-line"></div>
      </div>

      <div class="victory-actions">
          <button id="confirm-relic-btn" class="btn btn-primary" disabled>Confirmar Sele√ß√£o</button>
      </div>
  </div>
</div>

<script>

  /*
  ================================================================================
                          SISTEMA DE RECOMPENSAS P√ìS-BATALHA
  ================================================================================

  FLUXO COMPLETO:

  1. DERROTA DO INIMIGO (battle.py - damage_boss()):
    - Jogador ataca e derrota inimigo
    - Recompensas s√£o CALCULADAS mas N√ÉO aplicadas ao jogador
    - Dados salvos na sess√£o: session['pending_rewards'] 
    - Se for lembran√ßa: session['pending_memory_reward']
    - Inimigo marcado como derrotado no banco de dados
    - Redirecionamento autom√°tico para o hub

  2. DETEC√á√ÉO NO HUB (checkForRecentVictory()):
    - Verifica localStorage por vit√≥ria recente (√∫ltimos 10s)
    - Tira snapshot dos HUDs para anima√ß√µes posteriores
    - Verifica no servidor se h√° recompensa de lembran√ßa pendente
    - Define window.__pendingMemoryPopup se necess√°rio

  3. POP-UP DE VIT√ìRIA (showVictoryRewards()):
    - Mostra dano causado/recebido e tipo de recompensa
    - Bot√£o "Receber Recompensas" para confirmar
    - Barra de progresso da regi√£o (inimigos 1-20)

  4. APLICA√á√ÉO DAS RECOMPENSAS (acceptVictoryRewards()):
    - Chama /apply_victory_rewards no servidor
    - EXP, cristais, ouro ou ampulhetas s√£o aplicados ao jogador
    - Session['pending_rewards'] √© limpa
    - Pop-up de vit√≥ria √© fechado

  5. ATUALIZA√á√ÉO E ANIMA√á√ïES:
    - HUDs s√£o atualizados com novos valores
    - Anima√ß√µes aplicadas comparando snapshots
    - Valores que aumentaram ganham efeito visual

  6. LEMBRAN√áAS (se aplic√°vel):
    - Pop-up de sele√ß√£o aparece com 3 op√ß√µes aleat√≥rias
    - Jogador escolhe uma lembran√ßa
    - Lembran√ßa √© aplicada via /select_memory
    - HUD de lembran√ßas √© atualizado com anima√ß√£o
    - Session['pending_memory_reward'] √© limpa

  TIPOS DE RECOMPENSA:
  - crystals: Cristais de Mem√≥ria (permanente)
  - gold: Ouro (apenas para a run atual)  
  - hourglasses: Ampulhetas Eternas (permanente)
  - memories: Lembran√ßas (buffs para a run atual)

  FUN√á√ïES PRINCIPAIS:
  - damage_boss(): Calcula e salva recompensas
  - checkForRecentVictory(): Detecta vit√≥ria e inicia fluxo
  - showVictoryRewards(): Exibe pop-up de vit√≥ria  
  - acceptVictoryRewards(): Aplica recompensas no banco
  - checkMemoryReward(): Verifica lembran√ßas pendentes
  - selectMemory(): Processa sele√ß√£o de lembran√ßa

  SISTEMA DE SESS√ÉO:
  - pending_rewards: {exp_reward, crystals_gained, gold_gained, etc}
  - pending_memory_reward: {enemy_rarity, timestamp}
  - session_revision_count: Pontos de dano dispon√≠veis

  PONTOS CR√çTICOS:
  - Recompensas NUNCA s√£o aplicadas automaticamente
  - Jogador deve sempre confirmar clicando "Receber"
  - Anima√ß√µes s√≥ ocorrem ap√≥s aplica√ß√£o real
  - Lembran√ßas verificadas direto no servidor (confi√°vel)
  - LocalStorage usado apenas para detectar vit√≥ria recente

  ================================================================================
  */

  // === SISTEMA DE SONS ===
  function playSound(audioPath, volume = 0.6) {
      try {
          const audio = new Audio(audioPath);
          audio.volume = volume;
          audio.play().catch(err => {
              console.warn("Som n√£o p√¥de ser reproduzido:", err);
          });
      } catch (e) {
          console.error("Erro ao tocar som:", e);
      }
  }

  function playRewardPopupSound() {
      playSound("/static/game.data/sounds/rewardpopup.mp3", 0.7);
  }

  function playMemoryOptionsSound() {
      playSound("/static/game.data/sounds/memoryoptions.mp3", 0.6);
  }

  function playMemorySelectionSound() {
      playSound("/static/game.data/sounds/memoryselection.mp3", 0.8);
  }

  function playEnemySelectionSound() {
      playSound("/static/game.data/sounds/enemyselection.mp3", 0.8);
  }

  function playEnemySelectionCloseSound() {
      playSound("/static/game.data/sounds/enemyselectionclose.mp3", 0.5);
  }

  // ===== SISTEMA DE MEM√ìRIAS =====

  let memoryOptions = [];
  let selectedMemoryType = null;

  // Verificar se h√° recompensa de mem√≥ria pendente
  function checkMemoryReward() {
      console.log("üîç DEBUG: checkMemoryReward() chamada");
      console.log("üîç DEBUG: checkMemoryReward chamada");
      
      fetch('/gamification/check_memory_reward')
          .then(response => response.json())
          .then(data => {
              console.log("üîç DEBUG: Resposta do check_memory_reward:", data);
              if (data.success && data.has_memory_reward) {
                  showMemorySelectionPopup(data.enemy_rarity);
              }
          })
          .catch(error => {
              console.error('Erro ao verificar recompensa de mem√≥ria:', error);
          });
  }

  // Mostrar pop-up de sele√ß√£o de mem√≥rias
  function showMemorySelectionPopup(enemyRarity) {
      console.log("üß† DEBUG: showMemorySelectionPopup chamada com raridade:", enemyRarity);
      
      // Salvar dados da recompensa para usar depois
      window.__pendingMemoryData = { enemy_rarity: enemyRarity };
      
      fetch('/gamification/get_memory_options')
          .then(response => response.json())
          .then(data => {
              console.log("üß† DEBUG: Op√ß√µes recebidas:", data);
              if (data.success) {
                  memoryOptions = data.options;
                  displayMemoryOptions(enemyRarity);
                  
                  // Reset do estado de sele√ß√£o
                  selectedMemoryType = null;
                  const confirmBtn = document.getElementById('confirm-memory-btn');
                  if (confirmBtn) {
                      confirmBtn.disabled = true;
                      confirmBtn.textContent = 'Confirmar Sele√ß√£o';
                  }
                  
                  // TOCAR SOM DO POP-UP DE MEM√ìRIAS
                  playMemoryOptionsSound();

                  console.log("üß† DEBUG: Mostrando pop-up");
                  window.__preRewardSnapshots = {
                    currencies: snapshotHudValues(document.getElementById('currencies-hud')),
                    buffs:      snapshotHudValues(document.getElementById('run-buffs-hud'))
                  };
                  document.getElementById('memory-selection-popup').style.display = 'flex';
              }
          })
          .catch(error => {
              console.error('Erro ao carregar op√ß√µes de mem√≥ria:', error);
          });
  }

    // Exibir op√ß√µes de mem√≥ria
    function displayMemoryOptions(enemyRarity) {
        const container = document.getElementById('memory-options-container');
        container.innerHTML = '';
        
        // ===== Grid din√¢mico baseado no n√∫mero de op√ß√µes =====
        const cols = Math.min(memoryOptions.length, 4);
        container.style.gridTemplateColumns = `repeat(${cols}, 240px)`;
        
        // Atualizar largura do painel pai
        const panel = document.querySelector('.victory-popup .victory-content');
        if (panel) panel.style.setProperty('--cols', cols);
        // ===== FIM =====
        
        memoryOptions.forEach(option => {
            const optionElement = document.createElement('div');
            optionElement.className = 'memory-option';
            optionElement.dataset.memoryType = option.type;
            
            optionElement.innerHTML = `
                <div class="memory-header">
                    <h3 class="memory-name-latin">${option.name}</h3>
                    ${option.current_count > 0 ? `<div class="memory-count">${option.current_count}</div>` : ''}
                </div>
                <img src="/static/game.data/buffs/${option.icon}" alt="${option.name}" class="memory-icon">
                <div class="memory-description">${option.description}</div>
                <div class="memory-value">${option.formatted_value}</div>
            `;
            
            optionElement.addEventListener('click', () => selectMemoryOption(option.type));
            container.appendChild(optionElement);
        });
    }

  // Selecionar op√ß√£o de mem√≥ria (apenas visual)
  function selectMemoryOption(memoryType) {
      console.log("üß† DEBUG: Selecionando op√ß√£o:", memoryType);
      
      // Remover sele√ß√£o anterior
      document.querySelectorAll('.memory-option').forEach(el => {
          el.classList.remove('selected');
      });

      // Marcar como selecionado
      const clickedOption = event.target.closest('.memory-option');
      if (clickedOption) {
          clickedOption.classList.add('selected');
          selectedMemoryType = memoryType;
          
          // Habilitar bot√£o de confirmar
          const confirmBtn = document.getElementById('confirm-memory-btn');
          if (confirmBtn) {
              confirmBtn.disabled = false;
              confirmBtn.textContent = `Confirmar: ${memoryOptions.find(opt => opt.type === memoryType)?.name || 'Lembran√ßa'}`;
          }
          
          console.log("üß† DEBUG: Op√ß√£o selecionada:", memoryType);
      }
  }

  // Confirmar sele√ß√£o de mem√≥ria (enviar para servidor)
  function confirmMemorySelection() {
      if (!selectedMemoryType) {
          alert('Selecione uma lembran√ßa primeiro!');
          return;
      }
      
      // Obter raridade do inimigo da sess√£o
      const pendingMemory = window.__pendingMemoryData || {};
      const enemyRarity = pendingMemory.enemy_rarity || 1;
      
      console.log("üß† DEBUG: Confirmando sele√ß√£o:", { memoryType: selectedMemoryType, enemyRarity });
      
      // Desabilitar bot√£o para evitar cliques duplos
      const confirmBtn = document.getElementById('confirm-memory-btn');
      if (confirmBtn) {
          confirmBtn.disabled = true;
          confirmBtn.textContent = 'Aplicando...';
      }

      // Enviar sele√ß√£o para o servidor
      fetch('/gamification/select_memory', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
              memory_type: selectedMemoryType,
              enemy_rarity: enemyRarity
          })
      })
      .then(response => response.json())
      .then(data => {
          console.log("üß† DEBUG: Resposta do servidor:", data);
          
          if (data.success) {
              // TOCAR SOM DE SELE√á√ÉO DE MEM√ìRIA
              playMemorySelectionSound();
              
              // Mostrar mensagem de sucesso
              addNotification(data.message);

              // DEBUG: Mostrar valores retornados
              console.log("üß† DEBUG: Buff aplicado:", {
                  type: data.buff_type,
                  value: data.value,
                  total_count: data.total_count,
                  total_value: data.total_value
              });

              // Fechar pop-up ap√≥s delay
              setTimeout(async () => {
                  // 1) Fechar o pop-up
                  const popup = document.getElementById('memory-selection-popup');
                  if (popup) popup.style.display = 'none';

                  // 2) Atualizar lembran√ßas no frontend
                  console.log("üß† Atualizando lembran√ßas ap√≥s sele√ß√£o...");
                  if (typeof updateActiveRunBuffs === 'function') {
                      await updateActiveRunBuffs();
                  }

                  // 2.5) Atualizar rel√≠quias tamb√©m
                  console.log("üó°Ô∏è Atualizando rel√≠quias ap√≥s vit√≥ria...");
                  if (typeof updateActiveRelics === 'function') {
                      await updateActiveRelics();
                  }

                  // 3) Aguardar update terminar
                  await new Promise(resolve => setTimeout(resolve, 50));

                  // 4) Aplicar anima√ß√£o espec√≠fica nas lembran√ßas
                  const runBuffsHud = document.getElementById('run-buffs-hud');
                  if (runBuffsHud) {
                      // Tirar novo snapshot para comparar
                      const newSnapshot = snapshotHudValues(runBuffsHud);

                      // Se havia snapshot anterior das lembran√ßas, comparar
                      const oldSnapshot = window.__preRewardSnapshots?.buffs || new Map();
                      diffAndAnimate(runBuffsHud, oldSnapshot);

                      console.log("‚ú® Anima√ß√£o de lembran√ßas aplicada");
                  }

                  // 5) Reset final
                  selectedMemoryType = null;
                  window.__pendingMemoryData = null;

              }, 300);
          } else {
              addNotification('Erro: ' + data.message);
              
              // Reabilitar bot√£o em caso de erro
              if (confirmBtn) {
                  confirmBtn.disabled = false;
                  confirmBtn.textContent = 'Confirmar Sele√ß√£o';
              }
          }
      })
      .catch(error => {
          console.error('Erro ao selecionar mem√≥ria:', error);
          addNotification('Erro ao selecionar mem√≥ria');
          
          // Reabilitar bot√£o em caso de erro
          if (confirmBtn) {
              confirmBtn.disabled = false;
              confirmBtn.textContent = 'Confirmar Sele√ß√£o';
          }
      });
  }

  // Event listeners para o pop-up de mem√≥ria
  document.addEventListener('DOMContentLoaded', () => {
      // Bot√£o de confirmar
      const confirmBtn = document.getElementById('confirm-memory-btn');
      if (confirmBtn) {
          confirmBtn.addEventListener('click', confirmMemorySelection);
      }
  });

  // Verificar mem√≥rias ao carregar a p√°gina (s√≥ se n√£o houver vit√≥ria recente)
  document.addEventListener('DOMContentLoaded', () => {
      // S√≥ verificar mem√≥rias se n√£o estivermos processando uma vit√≥ria recente
      const lastVictory = localStorage.getItem('lastVictoryTime');
      const now = Date.now();
      const hasRecentVictory = lastVictory && (now - parseInt(lastVictory)) < 10000;
      
      if (!hasRecentVictory) {
          checkMemoryReward();
      }
      updateActiveRunBuffs();
      updateActiveRelics();
  });


  // Atualizar exibi√ß√£o de buffs ativos
  function updateActiveRunBuffs(skipDomUpdate = false) {
      // Se h√° anima√ß√£o pendente, apenas retornar os dados sem atualizar DOM
      if (skipDomUpdate) {
          return fetch('/gamification/get_active_run_buffs')
              .then(response => response.json())
              .then(data => {
                  console.log("üß† Dados de buffs obtidos (sem atualizar DOM):", data);
                  return data;
              });
      }
      
      // Comportamento normal - atualizar DOM
      return fetch('/gamification/get_active_run_buffs')
          .then(response => response.json())
          .then(data => {
              if (data.success) {
                  displayActiveRunBuffs(data.buffs);
                  console.log("üß† Buffs atualizados no DOM:", data);
              }
              return data;
          })
          .catch(error => {
              console.error('Erro ao carregar buffs ativos:', error);
              return null;
          });
  }

  // Exibir buffs ativos na interface
  function displayActiveRunBuffs(buffs) {
    const hud = document.getElementById('run-buffs-hud');
    if (!hud) return;

    if (!buffs || buffs.length === 0) {
      hud.style.display = 'none';
      hud.innerHTML = '';
      return;
    }

    hud.style.display = 'flex';
    hud.innerHTML = '';

    // Cada buff vira um "currency-item" para herdar o mesmo visual
    buffs.forEach(buff => {
      const item = document.createElement('div');
      item.className = 'currency-item';

      // >>> ADICIONE esta linha (chave √∫nica para diff/anim):
      item.setAttribute('data-key', buff.name);

      item.innerHTML = `
        <img src="/static/game.data/buffs/${buff.icon}" alt="${buff.name}" class="currency-icon tooltip-trigger">
        <span class="currency-value tooltip-trigger">${buff.display_value}</span>
        <div class="custom-tooltip">
          <div class="tooltip-name">${buff.name}${buff.count > 1 ? ` (${buff.count})` : ''}</div>
          <div class="tooltip-description">${buff.description}</div>
          <div class="tooltip-value">${buff.display_value}</div>
        </div>
      `;

      hud.appendChild(item);
    });
  }

    // ===== SISTEMA DE REL√çQUIAS =====

    // Atualizar exibi√ß√£o de rel√≠quias ativas
    function updateActiveRelics(skipDomUpdate = false) {
        if (skipDomUpdate) {
            return fetch('/gamification/get_player_relics')
                .then(response => response.json())
                .then(data => {
                    console.log("üó°Ô∏è Dados de rel√≠quias obtidos (sem atualizar DOM):", data);
                    return data;
                });
        }
        
        return fetch('/gamification/get_player_relics')
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    displayActiveRelics(data.relics);
                    console.log("üó°Ô∏è Rel√≠quias atualizadas no DOM:", data);
                }
                return data;
            })
            .catch(error => {
                console.error('Erro ao carregar rel√≠quias ativas:', error);
                return null;
            });
    }

    // Exibir rel√≠quias ativas na barra horizontal
    function displayActiveRelics(relics) {
        const bar = document.getElementById('relics-bar');
        const items = document.getElementById('relics-bar-items');
        
        if (!bar || !items) return;

        if (!relics || relics.length === 0) {
            bar.style.display = 'none';
            items.innerHTML = '';
            return;
        }

        bar.style.display = 'block';
        items.innerHTML = '';

        relics.forEach(relic => {
            const item = document.createElement('div');
            
            // Mapear raridades
            const rarityMap = {
                'common': 'common',
                'uncommon': 'rare',
                'rare': 'rare',
                'epic': 'epic',
                'legendary': 'legendary'
            };
            
            const normalizedRarity = rarityMap[relic.rarity] || 'common';
            
            item.className = 'relic-bar-item';
            item.setAttribute('data-rarity', normalizedRarity);
            item.setAttribute('data-key', relic.name);

            item.innerHTML = `
                <img src="/static/game.data/relics/${relic.icon}" 
                    alt="${relic.name}" 
                    class="relic-bar-icon"
                    onerror="this.src='/static/game.data/relics/placeholder.png'">
                ${relic.counter_value && relic.counter_value > 0 ? `
                    <div class="relic-bar-counter">${relic.counter_value}</div>
                ` : ''}
                <div class="relic-tooltip">
                    <div class="relic-tooltip-name">${relic.name}</div>
                    <div class="relic-tooltip-desc">${relic.description}</div>
                </div>
            `;

            items.appendChild(item);
        });
    }

  function dismissClassNotification() {
    const notification = document.querySelector('.class-choice-notification');
    if (notification) {
      // Animar sa√≠da
      notification.style.animation = 'fadeOut 0.3s ease-out';
      notification.style.opacity = '0';
      notification.style.transform = 'translate(-50%, -50%) scale(0.9)';
      
      // Remover ap√≥s anima√ß√£o
      setTimeout(() => {
        notification.remove();
      }, 300);
      
      // Salvar no localStorage para n√£o mostrar novamente nesta sess√£o
      localStorage.setItem('classNotificationDismissed', 'true');
    }
  }
  
  // Verificar se a notifica√ß√£o foi dispensada nesta sess√£o
  document.addEventListener('DOMContentLoaded', function() {
    if (localStorage.getItem('classNotificationDismissed') === 'true') {
      const notification = document.querySelector('.class-choice-notification');
      if (notification) {
        notification.style.display = 'none';
      }
    }
    
    // Limpar flag quando sair da p√°gina
    window.addEventListener('beforeunload', function() {
      localStorage.removeItem('classNotificationDismissed');
    });
  });

  // ===== SISTEMA DE REL√çQUIAS =====

  let relicOptions = [];
  let selectedRelicId = null;

  // Verificar se h√° recompensa de rel√≠quia pendente
  function checkRelicReward() {
      console.log("üó°Ô∏è DEBUG: checkRelicReward() chamada");
      
      fetch('/gamification/check_relic_reward')
          .then(response => response.json())
          .then(data => {
              console.log("üó°Ô∏è DEBUG: Resposta do check_relic_reward:", data);
              if (data.success && data.has_relic_reward) {
                  showRelicSelectionPopup(data.context, data.count);
              }
          })
          .catch(error => {
              console.error('Erro ao verificar recompensa de rel√≠quia:', error);
          });
  }

  // Mostrar pop-up de sele√ß√£o de rel√≠quias
  function showRelicSelectionPopup(context, count) {
      console.log("üó°Ô∏è DEBUG: showRelicSelectionPopup chamada", { context, count });

      fetch('/gamification/get_relic_options')
          .then(response => response.json())
          .then(data => {
              console.log("üó°Ô∏è DEBUG: Op√ß√µes recebidas:", data);
              if (data.success) {
                  relicOptions = data.options;
                  displayRelicOptions();

                  // Reset do estado de sele√ß√£o
                  selectedRelicId = null;
                  const confirmBtn = document.getElementById('confirm-relic-btn');
                  if (confirmBtn) {
                      confirmBtn.disabled = true;
                      confirmBtn.textContent = 'Confirmar Sele√ß√£o';
                  }

                  // Atualizar divider de reroll
                  updateRelicRewriteDivider();

                  console.log("üó°Ô∏è DEBUG: Mostrando pop-up");
                  document.getElementById('relic-selection-popup').style.display = 'flex';
              }
          })
          .catch(error => {
              console.error('Erro ao carregar op√ß√µes de rel√≠quia:', error);
          });
  }

    // Exibir op√ß√µes de rel√≠quias
    function displayRelicOptions() {
        const container = document.getElementById('relic-options-container');
        container.innerHTML = '';
        
        // ===== Grid din√¢mico baseado no n√∫mero de op√ß√µes =====
        const cols = Math.min(relicOptions.length, 4);
        container.style.gridTemplateColumns = `repeat(${cols}, 280px)`;
        
        // Atualizar largura do painel pai
        const panel = document.querySelector('.ui-panel.relic-selection-modal');
        if (panel) panel.style.setProperty('--cols', cols);
        // ===== FIM =====
        
        // Mapear raridades para nomes traduzidos (SEM "incomum")
        const rarityNames = {
            'common': 'Comum',
            'uncommon': 'Rara',  // Mapear uncommon para Rara
            'rare': 'Rara',
            'epic': '√âpica',
            'legendary': 'Lend√°ria'
        };
        
        relicOptions.forEach(option => {
            const optionElement = document.createElement('div');
            
            // Normalizar raridades: uncommon vira rare
            let normalizedRarity = option.rarity;
            if (normalizedRarity === 'uncommon') {
                normalizedRarity = 'rare';
            }
            
            optionElement.className = `relic-option rarity-${normalizedRarity}`;
            optionElement.dataset.relicId = option.id;
            
            // Nome traduzido da raridade
            const rarityName = rarityNames[option.rarity] || rarityNames[normalizedRarity];
            
            optionElement.innerHTML = `
                <h3 class="relic-name">${option.name}</h3>
                <img src="/static/game.data/relics/${option.icon}" alt="${option.name}" class="relic-icon" onerror="this.src='/static/game.data/relics/placeholder.png'">
                <div class="relic-description">${option.description}</div>
                <div class="relic-rarity-label rarity-${normalizedRarity}">${rarityName}</div>
            `;
            
            optionElement.addEventListener('click', () => selectRelicOption(option.id));
            container.appendChild(optionElement);
        });
    }

  // Selecionar op√ß√£o de rel√≠quia (apenas visual)
  function selectRelicOption(relicId) {
      console.log("üó°Ô∏è DEBUG: Selecionando op√ß√£o:", relicId);
      
      // Remover sele√ß√£o anterior
      document.querySelectorAll('.relic-option').forEach(el => {
          el.classList.remove('selected');
      });

      // Marcar como selecionado
      const clickedOption = event.target.closest('.relic-option');
      if (clickedOption) {
          clickedOption.classList.add('selected');
          selectedRelicId = relicId;
          
          // Habilitar bot√£o de confirmar
          const confirmBtn = document.getElementById('confirm-relic-btn');
          if (confirmBtn) {
              confirmBtn.disabled = false;
              const selectedRelic = relicOptions.find(opt => opt.id === relicId);
              confirmBtn.textContent = `Confirmar: ${selectedRelic?.name || 'Rel√≠quia'}`;
          }
          
          console.log("üó°Ô∏è DEBUG: Op√ß√£o selecionada:", relicId);
      }
  }

    // Confirmar sele√ß√£o de rel√≠quia
    function confirmRelicSelection() {
        if (!selectedRelicId) {
            alert('Selecione uma rel√≠quia primeiro!');
            return;
        }
        
        console.log("üó°Ô∏è DEBUG: Confirmando sele√ß√£o:", selectedRelicId);
        
        // Desabilitar bot√£o
        const confirmBtn = document.getElementById('confirm-relic-btn');
        if (confirmBtn) {
            confirmBtn.disabled = true;
            confirmBtn.textContent = 'Aplicando...';
        }

        // Enviar sele√ß√£o
        fetch('/gamification/select_relic', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ relic_id: selectedRelicId })
        })
        .then(response => response.json())
        .then(data => {
            console.log("üó°Ô∏è DEBUG: Resposta do servidor:", data);
            
            if (data.success) {
                // Mostrar notifica√ß√£o
                addNotification(data.message);
                
                // Verificar se h√° mais rel√≠quias
                if (data.has_more_relics) {
                    console.log(`üîÑ Restam ${data.remaining_count} rel√≠quia(s). Reabrindo pop-up...`);
                    
                    // Fechar pop-up atual
                    const popup = document.getElementById('relic-selection-popup');
                    if (popup) popup.style.display = 'none';

                    // Reabrir ap√≥s delay
                    setTimeout(() => {
                        showRelicSelectionPopup('last_boss', data.remaining_count);
                    }, 500);

                } else {
                    // √öltima rel√≠quia, fechar definitivamente
                    console.log("‚úÖ Todas as rel√≠quias escolhidas!");

                    setTimeout(() => {
                        const popup = document.getElementById('relic-selection-popup');
                        if (popup) popup.style.display = 'none';

                        selectedRelicId = null;
                    }, 500);
                }
                
            } else {
                addNotification('Erro: ' + data.message);
                
                if (confirmBtn) {
                    confirmBtn.disabled = false;
                    confirmBtn.textContent = 'Confirmar Sele√ß√£o';
                }
            }
        })
        .catch(error => {
            console.error('Erro ao selecionar rel√≠quia:', error);
            addNotification('Erro ao selecionar rel√≠quia');
            
            if (confirmBtn) {
                confirmBtn.disabled = false;
                confirmBtn.textContent = 'Confirmar Sele√ß√£o';
            }
        });
    }

  // ===== SISTEMA DE REROLL PARA REL√çQUIAS =====

  function updateRelicRewriteDivider() {
      fetch('/gamification/get_player_currencies')
          .then(response => response.json())
          .then(data => {
              if (data.success) {
                  const eternalHourglasses = data.eternal_hourglasses || 0;
                  const relicRerollCount = data.relic_reroll_count || 0;

                  const cost = (relicRerollCount + 1) * 3;
                  const canReroll = relicRerollCount < 3 && eternalHourglasses >= cost;

                  // Atualizar custo no bot√£o
                  const costElement = document.getElementById('relic-rewrite-cost');
                  if (costElement) {
                      costElement.textContent = cost;
                  }

                  // Mostrar/ocultar divider baseado na disponibilidade
                  const divider = document.getElementById('relic-rewrite-divider');
                  if (divider) {
                      divider.style.display = 'flex';

                      // Adicionar classe de disabled se n√£o puder reroll
                      const button = document.getElementById('relic-rewrite-button');
                      if (button) {
                          if (canReroll) {
                              button.classList.remove('disabled');
                          } else {
                              button.classList.add('disabled');
                          }
                      }
                  }
              }
          })
          .catch(error => {
              console.error('Erro ao obter currencies:', error);
          });
  }

  async function executeRelicRewrite() {
      const button = document.getElementById('relic-rewrite-button');
      if (button && button.classList.contains('disabled')) {
          return; // N√£o fazer nada se estiver disabled
      }

      // Adicionar classe de anima√ß√£o
      button.classList.add('rewriting');

      // Tocar som
      const audio = new Audio('/static/game.data/sounds/rewrite.mp3');
      audio.volume = 0.5;
      audio.play().catch(err => console.log("Erro ao tocar som de rewrite:", err));

      try {
          const response = await fetch('/gamification/rewrite_relics', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' }
          });

          const data = await response.json();

          if (data.success) {
              console.log("‚ú® Reroll executado com sucesso!");

              // Animar fade out das op√ß√µes
              const container = document.getElementById('relic-options-container');
              if (container) {
                  container.style.opacity = '0';
                  container.style.transition = 'opacity 0.5s ease-out';

                  setTimeout(() => {
                      // Recarregar op√ß√µes
                      fetch('/gamification/get_relic_options')
                          .then(response => response.json())
                          .then(newData => {
                              if (newData.success) {
                                  relicOptions = newData.options;
                                  displayRelicOptions();

                                  // Reset sele√ß√£o
                                  selectedRelicId = null;
                                  const confirmBtn = document.getElementById('confirm-relic-btn');
                                  if (confirmBtn) {
                                      confirmBtn.disabled = true;
                                      confirmBtn.textContent = 'Confirmar Sele√ß√£o';
                                  }

                                  // Atualizar divider
                                  updateRelicRewriteDivider();

                                  // Fade in
                                  setTimeout(() => {
                                      container.style.opacity = '1';
                                      button.classList.remove('rewriting');
                                  }, 50);
                              }
                          })
                          .catch(error => {
                              console.error('Erro ao recarregar op√ß√µes:', error);
                              button.classList.remove('rewriting');
                          });
                  }, 500);
              }
          } else {
              addNotification(data.message || 'Erro ao reescrever escolhas');
              button.classList.remove('rewriting');
          }
      } catch (error) {
          console.error('Erro ao executar reroll:', error);
          addNotification('Erro ao reescrever escolhas');
          button.classList.remove('rewriting');
      }
  }

  // Event listeners
  document.addEventListener('DOMContentLoaded', () => {
      const confirmBtn = document.getElementById('confirm-relic-btn');
      if (confirmBtn) {
          confirmBtn.addEventListener('click', confirmRelicSelection);
      }

      const relicRewriteBtn = document.getElementById('relic-rewrite-button');
      if (relicRewriteBtn) {
          relicRewriteBtn.addEventListener('click', executeRelicRewrite);
      }

      // Verificar rel√≠quias ao carregar
      checkRelicReward();
  });
</script>

<script>

  // Tira um snapshot dos valores num√©ricos atuais de um HUD (por nome)
  function snapshotHudValues(hudEl) {
    if (!hudEl) return new Map();
    const map = new Map();
    hudEl.querySelectorAll('.currency-item').forEach(item => {
      const nameEl = item.querySelector('.currency-name');
      const valueEl = item.querySelector('.currency-value');
      const key = nameEl ? nameEl.textContent.trim().replace(/:$/, '') : item.getAttribute('data-key') || '';
      if (!valueEl || !key) return;
      const num = parseFloat(String(valueEl.textContent).replace(/[^\d.-]/g,''));
      map.set(key, isNaN(num) ? valueEl.textContent.trim() : num);
    });
    return map;
  }

  // Marca o elemento como "changed" e remove a classe ao terminar a anima√ß√£o (ou por timeout)
  function markChanged(el) {
    if (!el) return;
    el.classList.remove('changed'); // reset para re-disparar
    // for√ßar reflow para reiniciar a anima√ß√£o, caso a classe j√° estivesse aplicada
    void el.offsetWidth;
    el.classList.add('changed');
    const remove = () => el.classList.remove('changed');
    el.addEventListener('animationend', remove, { once: true });
    // Fallback de seguran√ßa
    setTimeout(remove, 1200);
  }

  // Compara snapshot anterior x estado atual e aplica anima√ß√£o s√≥ nos que aumentaram / mudaram
  function diffAndAnimate(hudEl, beforeMap) {
    if (!hudEl || !beforeMap) return;

    hudEl.querySelectorAll('.currency-item').forEach(item => {
      const nameEl  = item.querySelector('.currency-name');
      const valueEl = item.querySelector('.currency-value');
      const key = nameEl
        ? nameEl.textContent.trim().replace(/:$/, '')
        : (item.getAttribute('data-key') || '');
      if (!valueEl || !key) return;

      const before   = beforeMap.get(key);
      const nowText  = valueEl.textContent.trim();
      const nowNum   = parseFloat(nowText.replace(/[^\d.-]/g,''));
      const beforeIsNumber = (typeof before === 'number' && Number.isFinite(before));
      const nowIsNumber    = !Number.isNaN(nowNum);

      // Regras:
      // 1) se ambos s√£o n√∫meros: anima forte se AUMENTOU (contador + part√≠culas)
      // 2) se diminuiu ou mudou (n√£o-num√©rico): mant√©m s√≥ o pop visual padr√£o
      if (beforeIsNumber && nowIsNumber) {
        if (nowNum > before) {
          markChanged(valueEl);                     // sua anima√ß√£o CSS .changed
          animateCounter(valueEl, before, nowNum);  // contador subindo
          spawnSparkles(valueEl, 8);                // part√≠culas r√°pidas
          playCurrencyUpSound();
        } else if (nowNum !== before) {
          markChanged(valueEl);                     // mudou pra baixo: s√≥ o pop
        }
      } else {
        if (before !== undefined && String(before) !== nowText) {
          markChanged(valueEl);                     // texto mudou: s√≥ o pop
          // se quiser part√≠culas tamb√©m aqui, descomente:
          // spawnSparkles(valueEl, 6);
        }
      }
    });
  }


  // Anima o n√∫mero subindo, de 'fromVal' at√© 'toVal'
  function animateCounter(el, fromVal, toVal, duration = 1200) {
    if (!el) return;
    // evita sobreposi√ß√£o de anima√ß√µes
    if (el.dataset.animating === '1') return;
    el.dataset.animating = '1';

    const start = performance.now();
    const from = Number(fromVal) || 0;
    const to   = Number(toVal) || 0;

    // se diferen√ßa √© pequena, acelera
    const dur = Math.max(500, duration * Math.min(1, Math.abs(to - from) / 50));

    function step(now) {
      const t = Math.min(1, (now - start) / dur);
      // easeOutCubic
      const e = 1 - Math.pow(1 - t, 3);
      const curr = Math.round(from + (to - from) * e);
      el.textContent = curr;
      if (t < 1) {
        requestAnimationFrame(step);
      } else {
        el.textContent = to;
        delete el.dataset.animating;
      }
    }
    requestAnimationFrame(step);
  }

  function spawnSparkles(valueEl, count = 8) {
    const item = valueEl.closest('.currency-item');
    if (!item) return;

    const base = item.getBoundingClientRect();
    const rect = valueEl.getBoundingClientRect();

    for (let i = 0; i < count; i++) {
      const s = document.createElement('span');
      s.className = 'sparkle';
      s.textContent = '‚ú¶'; // ou troque por s√≠mbolo/emoji diferente

      // posi√ß√£o inicial: centro aproximado do n√∫mero
      s.style.left = (rect.left - base.left + rect.width / 2) + 'px';
      s.style.top  = (rect.top  - base.top  + rect.height / 2) + 'px';
      item.appendChild(s);

      // dire√ß√£o aleat√≥ria
      const angle = Math.random() * Math.PI * 2; // 0 a 360 graus
      const dist = 15 + Math.random() * 20;      // raio de movimento em px
      const dx = Math.cos(angle) * dist;
      const dy = Math.sin(angle) * dist;

      // anima
      s.animate(
        [
          { transform: 'translate(0,0) scale(1)', opacity: 1 },
          { transform: `translate(${dx}px, ${dy}px) scale(.9)`, opacity: 0 }
        ],
        { duration: 520 + Math.random() * 240, easing: 'cubic-bezier(.2,.6,.2,1)' }
      ).onfinish = () => s.remove();
    }
  }

  function playCurrencyUpSound() {
    try {
      const audio = new Audio("/static/game.data/sounds/currency-up.mp3");
      audio.volume = 0.6; // ajusta o volume
      audio.play().catch(err => {
        // silenciosamente ignora erros (ex: autoplay bloqueado)
        console.warn("Som n√£o p√¥de ser reproduzido:", err);
      });
    } catch (e) {
      console.error("Erro ao tocar som:", e);
    }
  }

    function showVictoryRewards(data, victoryData = null) {
        // Usar dados passados diretamente ou fallback
        const realVictoryData = victoryData || data.detail || {};
        console.log("üèÜ DADOS DA VIT√ìRIA NO POP-UP:", realVictoryData);
        
        // Determinar qual recompensa foi recebida
        let rewardHtml = '';
        let rewardIconSrc = '';

        console.log("üèÜ DEBUG RECOMPENSA - rewardType:", realVictoryData.rewardType);
        console.log("üèÜ DEBUG RECOMPENSA - crystalsGained:", realVictoryData.crystalsGained);
        console.log("üèÜ DEBUG RECOMPENSA - goldGained:", realVictoryData.goldGained);
        console.log("üèÜ DEBUG RECOMPENSA - hourglassesGained:", realVictoryData.hourglassesGained);

        // ‚Üê PRIORIZAR O TIPO DE RECOMPENSA, N√ÉO O VALOR
        if (realVictoryData.rewardType === 'crystals') {
            const baseAmount = realVictoryData.crystalsBase ?? realVictoryData.crystalsGained ?? 20;
            const plural = baseAmount !== 1 ? "Cristais de Mem√≥ria" : "Cristal de Mem√≥ria";
            rewardHtml = `<span class="reward-value crystals-gained">${plural} (${baseAmount})</span>`;
            rewardIconSrc = '/static/game.data/crystal.png';
        } else if (realVictoryData.rewardType === 'gold') {
            const baseAmount = realVictoryData.goldBase ?? realVictoryData.goldGained ?? 5;
            rewardHtml = `<span class="reward-value gold-gained">Ouro (${baseAmount})</span>`;
            rewardIconSrc = '/static/game.data/gold.png';
        } else if (realVictoryData.rewardType === 'hourglasses') {
            const baseAmount = realVictoryData.hourglassesBase ?? realVictoryData.hourglassesGained ?? 1;
            const plural = baseAmount !== 1 ? "Ampulhetas Eternas" : "Ampulheta Eterna";
            rewardHtml = `<span class="reward-value hourglasses-gained">${plural} (${baseAmount})</span>`;
            rewardIconSrc = '/static/game.data/hourglass.png';
        } else if (realVictoryData.rewardType === 'memories') {
            rewardHtml = `<span class="reward-value memories-gained">Lembran√ßa Obtida</span>`;
            rewardIconSrc = '/static/game.data/memory.png';
        } else {
            // ‚Üê FALLBACK: Se n√£o tem tipo definido, usar o que tiver valor
            if (realVictoryData.crystalsGained && realVictoryData.crystalsGained > 0) {
                rewardHtml = `<span class="reward-value crystals-gained">${realVictoryData.crystalsGained} Cristais de Mem√≥ria</span>`;
                rewardIconSrc = '/static/game.data/crystal.png';
            } else if (realVictoryData.goldGained && realVictoryData.goldGained > 0) {
                rewardHtml = `<span class="reward-value gold-gained">${realVictoryData.goldGained} Ouro</span>`;
                rewardIconSrc = '/static/game.data/gold.png';
            } else if (realVictoryData.hourglassesGained && realVictoryData.hourglassesGained > 0) {
                rewardHtml = `<span class="reward-value hourglasses-gained">Ampulheta Eterna (${realVictoryData.hourglassesGained})</span>`;
                rewardIconSrc = '/static/game.data/hourglass.png';
            } else {
                // ‚Üê √öLTIMO FALLBACK
                rewardHtml = `<span class="reward-value crystals-gained">20 Cristais de Mem√≥ria</span>`;
                rewardIconSrc = '/static/game.data/crystal.png';
            }
        }

        // ‚Üê USAR √çCONE DO realVictoryData se dispon√≠vel
        if (realVictoryData.rewardIcon) {
            rewardIconSrc = `/static/game.data/${realVictoryData.rewardIcon}`;
        }
        
        // ===== PROCESSAR MENSAGENS DE B√îNUS DE REL√çQUIAS ANTES DE CRIAR O HTML =====
        let relicBonusHtml = '';
        if (realVictoryData.relic_bonus_messages) {
            const messages = realVictoryData.relic_bonus_messages.split('\n').filter(m => m.trim());
            if (messages.length > 0) {
                relicBonusHtml = `
                    <div class="relic-bonus-section">
                        ${messages.map(msg => {
                            // Formatar mensagem: remover emoji e reformatar
                            let cleanMsg = msg.replace(/[üí∞üíé‚è≥‚ú®]/g, '').trim();
                            cleanMsg = cleanMsg.replace(/^Rel√≠quias:\s*/i, '');
                            return `<div class="relic-bonus-message">B√¥nus por rel√≠quias: ${cleanMsg}</div>`;
                        }).join('')}
                    </div>`;
            }
        }
        
        const rewardPopup = document.createElement('div');
        // ADICIONAR ui-dialog no overlay:
        rewardPopup.className = 'ui-dialog victory-rewards-popup';

        // Envolver o conte√∫do com ui-panel:
        rewardPopup.innerHTML = `
        <div class="ui-panel victory-content-new">
            <h2 class="title">${realVictoryData.enemyName || 'Inimigo'} derrotado!</h2>

            <div class="battle-stats-compact">
                <div class="damage-stats-row">
                    <span class="damage-stat-left">DANO CAUSADO: <span class="stat-value damage-dealt">${realVictoryData.damageDealt ?? 0}</span></span>
                    <span class="damage-stat-right">DANO RECEBIDO: <span class="stat-value damage-taken">${realVictoryData.damageTaken ?? 0}</span></span>
                </div>
            </div>

            <div class="rewards-section-compact">
                <div class="reward-icon-large-container">
                    <img src="${rewardIconSrc}" alt="Recompensa" class="reward-icon-large">
                </div>
                <div class="reward-main">
                    ${rewardHtml}
                </div>
            </div>

            ${relicBonusHtml}

            <div class="progress-section">
                <span class="progress-text">Inimigos derrotados na regi√£o: ${(data.enemies_defeated % 20) || 20}/20</span>
                <div class="progress-bar-container">
                    <div class="progress-bar-fill"></div>
                </div>
            </div>

            <button class="victory-continue-btn" onclick="acceptVictoryRewards()">
                Receber Recompensas
            </button>
        </div>`;

        
        // Salvar dados para usar depois
        window.lastVictoryData = data;

        // >>> SNAPSHOT ANTES DE MOSTRAR O POP-UP <
        // S√≥ tirar snapshot se ainda n√£o foi tirado (para evitar sobrescrever)
        if (!window.__preRewardSnapshots) {
            window.__preRewardSnapshots = {
            currencies: snapshotHudValues(document.getElementById('currencies-hud')),
            buffs:      snapshotHudValues(document.getElementById('run-buffs-hud'))
            };
            console.log("üì∏ Snapshot tirado para compara√ß√£o:", window.__preRewardSnapshots);
        }
        
        document.body.appendChild(rewardPopup);

        // TOCAR SOM DO POP-UP DE RECOMPENSA
        playRewardPopupSound();

        // Animar barra de progresso
        setTimeout(() => {
            const progressBar = rewardPopup.querySelector('.progress-bar-fill');
            if (progressBar) {
                const enemiesInRegion = data.enemies_defeated % 20;
                const progressPercent = (enemiesInRegion / 20) * 100;
                
                console.log("üèÜ BARRA PROGRESSO DEBUG:");
                console.log("   enemies_defeated:", data.enemies_defeated);
                console.log("   enemiesInRegion:", enemiesInRegion);
                console.log("   progressPercent:", progressPercent);
                
                // ‚Üê ADICIONAR CLASSE DE ANIMA√á√ÉO
                progressBar.classList.add('animating');

                // ‚Üê ANIMAR GRADUALMENTE
                progressBar.style.width = `${progressPercent}%`;

                // ‚Üê REMOVER CLASSE AP√ìS ANIMA√á√ÉO
                setTimeout(() => {
                    progressBar.classList.remove('animating');
                }, 1000);
                
                console.log("   Largura aplicada:", progressBar.style.width);
            }
        }, 100);
    }

  // Nova fun√ß√£o para atualizar display de currencies
  function updateCurrencyDisplay(skipDomUpdate = false) {
      // Se h√° anima√ß√£o pendente, apenas retornar os dados sem atualizar DOM
      if (skipDomUpdate) {
          return fetch('/gamification/get_player_currencies')
              .then(response => response.json())
              .then(data => {
                  console.log("üí∞ Dados de currencies obtidos (sem atualizar DOM):", data);
                  return data;
              });
      }
      
      // Comportamento normal - atualizar DOM
      return fetch('/gamification/get_player_currencies')
          .then(response => response.json())
          .then(data => {
              if (data.success) {
                  // Atualizar valores direto (sem anima√ß√£o)
                  const crystalsEl = document.getElementById('crystals-value');
                  const goldEl = document.getElementById('gold-value');
                  const hourglassesEl = document.getElementById('hourglasses-value');
                  
                  if (crystalsEl) crystalsEl.textContent = data.crystals;
                  if (goldEl) goldEl.textContent = data.gold;
                  if (hourglassesEl) hourglassesEl.textContent = data.hourglasses;
                  
                  console.log("üí∞ Currencies atualizadas no DOM:", data);
              }
              return data;
          })
          .catch(error => {
              console.error('Erro ao atualizar currencies:', error);
              return null;
          });
  }

  function updateValueWithAnimation(elementId, newValue) {
    const element = document.getElementById(elementId);
    if (element && element.textContent !== String(newValue)) {
      element.textContent = newValue;
    }
  }

    async function acceptVictoryRewards() {
        // DEBOUNCE: Evitar cliques duplos
        if (window.processingRewards) {
            console.log("‚ö†Ô∏è J√° processando recompensas, ignorando clique");
            return;
        }
        window.processingRewards = true;
        
        console.log("üéÅ Aplicando recompensas...");
        
        // Desabilitar bot√£o para feedback visual
        const continueBtn = document.querySelector('.victory-continue-btn');
        if (continueBtn) {
            continueBtn.disabled = true;
            continueBtn.textContent = 'Processando...';
        }
      
      try {
          // 1) Chamar rota para aplicar recompensas no backend
          const response = await fetch('/gamification/apply_victory_rewards', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' }
          });
          
          const result = await response.json();
          console.log("üéÅ Resposta da aplica√ß√£o:", result);
          
          if (!result.success) {
              console.error('‚ùå Erro ao aplicar recompensas:', result.message);
              alert('Erro ao aplicar recompensas: ' + result.message);
              return;
          }
          
          // 2) Fechar pop-up de vit√≥ria
          const rewardPopup = document.querySelector('.victory-rewards-popup');
          if (rewardPopup) {
              rewardPopup.remove();
              console.log("‚úÖ Pop-up de vit√≥ria fechado");
          }

          // 3) Aguardar um pouco para suavizar a transi√ß√£o
          await new Promise(resolve => setTimeout(resolve, 100));

          // 4) NOVO: Obter dados atualizados SEM atualizar DOM ainda
          console.log("üîÑ Obtendo dados atualizados...");
          const [currencyData, buffsData] = await Promise.all([
              updateCurrencyDisplay(true), // skipDomUpdate = true
              updateActiveRunBuffs(true)   // skipDomUpdate = true
          ]);

          // 5) Aguardar um pouco mais
          await new Promise(resolve => setTimeout(resolve, 30));
          
          // 6) NOVO: Aplicar anima√ß√µes PRIMEIRO (com valores ainda antigos no DOM)
          if (window.__preRewardSnapshots) {
              console.log("‚ú® Aplicando anima√ß√µes com snapshot...");
              
              // Aplicar anima√ß√µes (que v√£o alterar o DOM gradualmente)
              const currenciesHud = document.getElementById('currencies-hud');
              const buffsHud = document.getElementById('run-buffs-hud');
              
              if (currenciesHud && window.__preRewardSnapshots.currencies) {
                  // Primeiro, atualizar valores finais no DOM (para onde a anima√ß√£o vai)
                  if (currencyData && currencyData.success) {
                      const crystalsEl = document.getElementById('crystals-value');
                      const goldEl = document.getElementById('gold-value');
                      const hourglassesEl = document.getElementById('hourglasses-value');
                      
                      if (crystalsEl) crystalsEl.textContent = currencyData.crystals;
                      if (goldEl) goldEl.textContent = currencyData.gold;
                      if (hourglassesEl) hourglassesEl.textContent = currencyData.hourglasses;
                  }
                  
                  // Ent√£o aplicar anima√ß√£o
                  diffAndAnimate(currenciesHud, window.__preRewardSnapshots.currencies);
              }
              
              if (buffsHud && window.__preRewardSnapshots.buffs) {
                  // Primeiro, atualizar buffs no DOM  
                  if (buffsData && buffsData.success) {
                      displayActiveRunBuffs(buffsData.buffs);
                  }
                  
                  // Ent√£o aplicar anima√ß√£o
                  diffAndAnimate(buffsHud, window.__preRewardSnapshots.buffs);
              }
              
              // Limpar snapshots
              window.__preRewardSnapshots = null;
          } else {
              // Fallback: atualizar normalmente se n√£o h√° snapshot
              console.log("‚ö†Ô∏è N√£o h√° snapshot, atualizando normalmente");
              await updateCurrencyDisplay(false);
              await updateActiveRunBuffs(false);
          }
          
          // 7) Mostrar level up se houver
          if (result.level_up) {
              addNotification(`üéâ Level Up! Voc√™ chegou ao n√≠vel ${result.new_level}!`);
          }
          
          // 8) Verificar se deve mostrar pop-up de mem√≥ria
          console.log("üèÜ DEBUG: window.__pendingMemoryPopup =", window.__pendingMemoryPopup);
          if (window.__pendingMemoryPopup) {
              window.__pendingMemoryPopup = false;
              console.log("üß† DEBUG: Iniciando processo de mem√≥ria");

              // Aguardar anima√ß√µes terminarem antes de mostrar o pr√≥ximo pop-up
              setTimeout(() => {
                  console.log("üß† DEBUG: Chamando checkMemoryReward()");
                  checkMemoryReward();
              }, 300);
          } else {
              console.log("‚ùå DEBUG: Nenhuma mem√≥ria pendente para mostrar");
          }
          
          // 9) Resetar flags
          window.victoryProcessed = false;
          window.processingRewards = false;
          
      } catch (error) {
          console.error('‚ùå Erro na aplica√ß√£o de recompensas:', error);
          alert('Erro de comunica√ß√£o: ' + error.message);
          
          // RESETAR FLAGS EM CASO DE ERRO
          window.processingRewards = false;
          const continueBtn = document.querySelector('.victory-continue-btn');
          if (continueBtn) {
              continueBtn.disabled = false;
              continueBtn.textContent = 'Receber Recompensas';
          }
      }
  }


  function checkForRecentVictory() {
      // Evitar processamento duplicado
      if (window.victoryProcessed) {
          return;
      }
      
      // S√≥ verificar se estamos no hub
      if (window.location.pathname === '/gamification' || window.location.pathname === '/gamification/') {
          const lastVictory = localStorage.getItem('lastVictoryTime');
          const victoryData = localStorage.getItem('victoryData');
          
          if (lastVictory && victoryData) {
              const now = Date.now();
              const victoryTime = parseInt(lastVictory);
              
              // Se a vit√≥ria foi nos √∫ltimos 10 segundos
              if (now - victoryTime < 10000) {
                  console.log("üéâ Vit√≥ria recente detectada!");
                  
                  // LIMPAR IMEDIATAMENTE para evitar processamento duplicado
                  localStorage.removeItem('lastVictoryTime');
                  localStorage.removeItem('victoryData');
                  
                  // Marcar como processado para evitar repeti√ß√µes
                  window.victoryProcessed = true;
                  window.processingVictory = true;
                  
                  // Processar dados da vit√≥ria
                  const parsedVictoryData = JSON.parse(victoryData);
                  console.log("üèÜ DADOS DA VIT√ìRIA:", parsedVictoryData);
                  
                  // Verificar se h√° recompensas pendentes no servidor
                  fetch('/gamification/boss_defeated', {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' }
                  })
                  .then(response => response.json())
                  .then(progressData => {
                      console.log("üìä Dados de progresso:", progressData);
                      
                      // Tirar snapshot ANTES de mostrar o pop-up
                      window.__preRewardSnapshots = {
                          currencies: snapshotHudValues(document.getElementById('currencies-hud')),
                          buffs: snapshotHudValues(document.getElementById('run-buffs-hud'))
                      };
                      console.log("üì∏ Snapshot tirado:", window.__preRewardSnapshots);
                      
                      // NOVO: Verificar diretamente no servidor se h√° recompensa de mem√≥ria
                      fetch('/gamification/check_memory_reward')
                          .then(response => response.json())
                          .then(memoryData => {
                              console.log("üß† DEBUG: Resposta do check_memory_reward:", memoryData);
                              
                              if (memoryData.success && memoryData.has_memory_reward) {
                                  window.__pendingMemoryPopup = true;
                                  console.log("üß† DEBUG: Marcando recompensa de mem√≥ria para ap√≥s pop-up");
                              } else {
                                  window.__pendingMemoryPopup = false;
                                  console.log("‚ùå DEBUG: N√ÉO √© recompensa de mem√≥ria");
                              }
                          })
                          .catch(error => {
                              console.error("‚ùå Erro ao verificar mem√≥ria:", error);
                              window.__pendingMemoryPopup = false;
                              showVictoryRewards(progressData, parsedVictoryData);
                          });
                      
                      // Mostrar pop-up de recompensa
                      showVictoryRewards(progressData, parsedVictoryData);
                  })
                  .catch(error => {
                      console.error("‚ùå Erro ao buscar progresso:", error);
                      // Fallback: mostrar pop-up mesmo assim
                      window.__preRewardSnapshots = {
                          currencies: snapshotHudValues(document.getElementById('currencies-hud')),
                          buffs: snapshotHudValues(document.getElementById('run-buffs-hud'))
                      };
                      showVictoryRewards({ enemies_defeated: 1 }, parsedVictoryData);
                  });
                  
              }
          }
      }
  }
  
  function startVictoryPolling() {
      // Verificar imediatamente ao carregar o hub
      checkForRecentVictory();
      
      // Verificar a cada 2 segundos se h√° vit√≥ria recente
      setInterval(() => {
          checkForRecentVictory();
      }, 2000);
  }

   // Esconder o bot√£o "Voltar ao Retina Cards" no footer
  document.addEventListener('DOMContentLoaded', function() {
    const footerButtons = document.querySelectorAll('.text-center.mt-4 .btn-secondary');
    footerButtons.forEach(button => {
      button.style.display = 'none';
    });
  });
</script>

<!-- Script de part√≠culas -->
<script src="https://cdn.jsdelivr.net/npm/particles.js"></script>
<script>
  particlesJS('particles-js', {
    "particles": {
      "number": { "value": 180 },
      "color": { "value": ["#888888", "#aaaaaa", "#cccccc", "#999999", "#bbbbbb"] },
      "shape": { "type": "circle" },
      "opacity": { 
        "value": 0.4,
        "random": true,
        "anim": {
          "enable": true,
          "speed": 1,
          "opacity_min": 0.1,
          "sync": false
        }
      },
      "size": { 
        "value": 2,
        "random": true,
        "anim": {
          "enable": true,
          "speed": 2,
          "size_min": 0.5,
          "sync": false
        }
      },
      "line_linked": { "enable": false },
      "move": {
        "enable": true,
        "speed": 0.3,
        "direction": "none",
        "random": true,
        "straight": false,
        "out_mode": "out",
        "bounce": false
      }
    },
    "interactivity": {
      "detect_on": "canvas",
      "events": { "onhover": { "enable": false } },
      "modes": {}
    },
    "retina_detect": true
  }); 
</script>

<script>

  // === VARI√ÅVEIS GLOBAIS ===
  let availableEnemies = [];
  let isNewBattleSession = false;

  // === FUN√á√ïES GLOBAIS PARA SELE√á√ÉO DE INIMIGOS ===
  function selectEnemy(enemyId, enemyName) {
      console.log("üéØ Selecionando inimigo:", enemyId, enemyName);

      // Resetar contador de dano para nova batalha
      window.totalBattleDamage = 0;
      window.battleInProgress = false;
      console.log("üîÑ Contador de dano resetado - novo inimigo selecionado");
      
      fetch('/gamification/select_enemy', {
          method: 'POST',
          headers: {
              'Content-Type': 'application/json',
          },
          body: JSON.stringify({
              enemy_id: enemyId
          })
      })
      .then(response => response.json())
      .then(data => {
          console.log("üìä Resposta do servidor:", data);
          
          if (data.success) {
              closeBossSelection();
              console.log(`‚úÖ Inimigo ${enemyName} selecionado!`);
              setTimeout(() => {
                  window.location.href = '/gamification/battle';
              }, 200);
          } else {
              alert('Erro ao selecionar inimigo: ' + data.message);
          }
      })
      .catch(error => {
          console.error('‚ùå Erro ao selecionar inimigo:', error);
          alert('Erro de comunica√ß√£o com o servidor');
      });
  }

  function selectBoss(bossId, bossName) {
      console.log("üëë Selecionando boss:", bossId, bossName);

      // Resetar contador de dano para nova batalha
      window.totalBattleDamage = 0;
      window.battleInProgress = false;
      console.log("üîÑ Contador de dano resetado - novo boss selecionado");
      
      fetch('/gamification/select_boss', {
          method: 'POST',
          headers: {
              'Content-Type': 'application/json',
          },
          body: JSON.stringify({
              boss_id: bossId
          })
      })
      .then(response => response.json())
      .then(data => {
          console.log("üìä Resposta do servidor:", data);
          
          if (data.success) {
              closeBossSelection();
              console.log(`‚úÖ Boss ${bossName} selecionado!`);
              setTimeout(() => {
                  window.location.href = '/gamification/battle';
              }, 200);
          } else {
              alert('Erro ao selecionar boss: ' + data.message);
          }
      })
      .catch(error => {
          console.error('‚ùå Erro ao selecionar boss:', error);
          alert('Erro de comunica√ß√£o com o servidor');
      });
  }

  function closeBossSelection() {
      const popup = document.getElementById('boss-selection-popup');
      if (popup) {
          // TOCAR SOM DE FECHAMENTO
          playEnemySelectionCloseSound();
          closeDialog('#boss-selection-popup');
      }
  }

  // === Utils Modal ===
  function openDialog(el) {
    const d = typeof el === 'string' ? document.querySelector(el) : el;
    if (!d) return;
    d.style.display = 'flex';
    // focus trap b√°sico:
    const focusable = d.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
    (focusable || d).focus();
    document.addEventListener('keydown', escToClose);
    d.dataset.open = "1";
  }
  function closeDialog(el) {
    const d = typeof el === 'string' ? document.querySelector(el) : el;
    if (!d) return;
    d.classList.add('ui-exit');
    setTimeout(()=>{ d.style.display = 'none'; d.classList.remove('ui-exit'); }, 140);
    document.removeEventListener('keydown', escToClose);
    d.dataset.open = "";
  }
  function escToClose(e){
    if (e.key === 'Escape') {
      document.querySelectorAll('.ui-dialog[data-open="1"]').forEach(d => closeDialog(d));
    }
  }

  function markEnemiesAsSeen(enemies) {
      const newEnemyIds = enemies.filter(enemy => enemy.is_new).map(enemy => enemy.id);
      
      if (newEnemyIds.length > 0) {
          fetch('/gamification/mark_enemies_seen', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ enemy_ids: newEnemyIds })
          }).catch(error => console.error('Erro ao marcar inimigos como vistos:', error));
      }
  }

  function showBossSelection(isNew = false) {
      isNewBattleSession = isNew;
    
      // Carregar inimigos dispon√≠veis
      fetch('/gamification/get_available_enemies')
          .then(response => response.json())
          .then(data => {
              if (data.success) {
                  // Salvar dados globalmente para renderEnemyCards
                  window.currentBossData = data;

                  if (data.is_boss_fight && data.boss) {
                      // √â boss fight - renderizar boss
                      availableEnemies = [data.boss];
                      renderEnemyCards([data.boss], isNew);

                      // Ocultar divider de reroll para boss
                      const divider = document.getElementById('enemy-rewrite-divider');
                      if (divider) {
                          divider.style.display = 'none';
                      }
                  } else {
                      // Inimigos gen√©ricos normais
                      availableEnemies = data.enemies;
                      renderEnemyCards(data.enemies, isNew);

                      // Atualizar divider de reroll apenas para inimigos normais
                      updateEnemyRewriteDivider();
                  }

                  playEnemySelectionSound();
                  openDialog('#boss-selection-popup');
              } else {
                  console.error('Erro ao carregar inimigos:', data.message);
              }
          })
          .catch(error => {
              console.error('Erro na requisi√ß√£o:', error);
          });
  }

  function renderEnemyCards(enemies, showNewAnimation = false) {
    const grid  = document.getElementById('enemy-grid');
    if (!grid) {
      console.error("‚ùå Elemento 'enemy-grid' n√£o encontrado!");
      return;
    }
    grid.innerHTML = '';

    // NOVO: Verificar se √© boss fight
    if (window.currentBossData && window.currentBossData.is_boss_fight && window.currentBossData.boss) {
        console.log("üëë Renderizando boss no pop-up:", window.currentBossData.boss);
        
        // Definir 1 coluna para boss
        const cols = 1;
        grid.style.display = 'grid';
        grid.style.gridTemplateColumns = `repeat(${cols}, 240px)`;
        
        const panel = document.querySelector('.ui-panel.boss-selection-modal');
        if (panel) panel.style.setProperty('--cols', cols);
        
        // Criar card do boss
        const bossCard = createEnemyCard(window.currentBossData.boss, showNewAnimation);
        grid.appendChild(bossCard);
        return;
    }

    // 1) Define a quantidade de colunas efetivas (m√°x. 3)
    const cols = Math.min(enemies.length, 4); // Suporta at√© 4 op√ß√µes

    // 2) Atualiza o grid para usar as colunas calculadas
    grid.style.display = 'grid';
    // Se voc√™ deixou o CSS com repeat(var(--cols)), esta linha √© opcional:
    grid.style.gridTemplateColumns = `repeat(${cols}, 240px)`;

    // 3) Passa a informa√ß√£o para o PAINEL (.ui-panel.boss-selection-modal)
    //    Isso vai dimensionar a largura do popup com a regra CSS calc(...)
    const panel = document.querySelector('.ui-panel.boss-selection-modal');
    if (panel) panel.style.setProperty('--cols', cols);

    // 4) Renderiza os cards
    enemies.forEach((enemy, index) => {
      const isNew = showNewAnimation && index >= enemies.length - 1;
      const card = createEnemyCard(enemy, isNew);
      grid.appendChild(card);
    });
  }


  function createEnemyCard(enemy, isNew = false) {
    console.log("üèÜ DADOS DO INIMIGO/BOSS:", enemy);
    
    const card = document.createElement('div');
    
    // Verificar se √© boss
    if (enemy.is_boss) {
        card.className = `enemy-card boss ${isNew ? 'new' : ''}`;
        
        // Construir sprite do boss (animada)
        const bossName = enemy.name.toLowerCase().replace(/\s+/g, '_'); // Converte nome para classe CSS
        const bossSprite = `<div class="boss-idle-sprite boss-${bossName}" style="background-image: url('/static/game.data/${enemy.sprite_idle}');"></div>`;
        
        card.innerHTML = `
            <div class="card-glow-effect"></div>
            <div class="card-slide-effect"></div>
            <div class="rarity-label boss">ESPECIAL</div>
            <h3 class="enemy-name">${enemy.name}</h3>
            <div class="enemy-sprite-container">
                ${bossSprite}
            </div>
            <div class="enemy-stats">
                <div><strong>HP:</strong> ${enemy.hp}</div>
                <div><strong>Dano:</strong> ${enemy.damage}</div>
                <div><strong>Postura:</strong> ${enemy.posture}</div>
                <div><strong>Defesa:</strong> ${enemy.block_percentage}%</div>
            </div>
            <!-- Bosses n√£o mostram recompensa no card -->
            </div>
            <button class="choose-enemy-btn boss-btn" onclick="selectBoss(${enemy.id}, '${enemy.name}')">
                Enfrentar Boss
            </button>
        `;
        
        return card;
    }
    
    // inimigos gen√©ricos
    card.className = `enemy-card rarity-${enemy.rarity} ${isNew ? 'new' : ''}`;
    
    // Construir sprites (apenas as camadas que existem)
    let spriteLayers = '';
    
    if (enemy.sprite_back) {
      spriteLayers += `<div class="enemy-sprite-layer" style="background-image: url('/static/game.data/enemies/back/${enemy.sprite_back}'); z-index: 1;"></div>`;
    }
    
    spriteLayers += `<div class="enemy-sprite-layer" style="background-image: url('/static/game.data/enemies/body/${enemy.sprite_body}'); z-index: 2;"></div>`;
    spriteLayers += `<div class="enemy-sprite-layer" style="background-image: url('/static/game.data/enemies/head/${enemy.sprite_head}'); z-index: 3;"></div>`;
    spriteLayers += `<div class="enemy-sprite-layer" style="background-image: url('/static/game.data/enemies/weapon/${enemy.sprite_weapon}'); z-index: 4;"></div>`;
    
    // ADICIONAR: Verificar se o inimigo √© novo (baseado em timestamp ou flag)
    const isNewEnemy = enemy.is_new || (enemy.created_at && Date.now() - new Date(enemy.created_at).getTime() < 60000); // Novo se criado h√° menos de 1 minuto
    
    card.innerHTML = `
      <div class="card-glow-effect"></div>
      <div class="card-slide-effect"></div>
      <div class="rounds-badge">${enemy.rounds_remaining}/${enemy.initial_rounds || 3}</div>
      ${isNewEnemy ? '<div class="new-enemy-badge">NOVO!</div>' : ''}
      <div class="rarity-label rarity-${enemy.rarity}">${enemy.rarity_name}</div>
      <div class="equipment-rank rank-${enemy.equipment_rank}">${enemy.equipment_rank === 'Supremo' ? 'Supremo' : 'Rank ' + enemy.equipment_rank}</div>
      <div class="reward-icon-container">
        <img src="/static/game.data/${enemy.reward_icon || 'crystal.png'}" alt="Recompensa" class="reward-icon-small">
      </div>
      <h3 class="enemy-name">${enemy.name}</h3>
      <div class="enemy-sprite-container">
        ${spriteLayers}
      </div>
      <div class="enemy-stats">
        <div><strong>HP:</strong> ${enemy.hp}</div>
        <div><strong>Dano:</strong> ${enemy.damage}</div>
        <div><strong>Postura:</strong> ${enemy.posture}</div>
      </div>
      <button class="choose-enemy-btn" onclick="selectEnemy(${enemy.id}, '${enemy.name}')">
        Escolher
      </button>
    `;
    
    return card;
}

  // ===== SISTEMA DE REROLL PARA INIMIGOS =====

  function updateEnemyRewriteDivider() {
      fetch('/gamification/get_player_currencies')
          .then(response => response.json())
          .then(data => {
              if (data.success) {
                  const eternalHourglasses = data.eternal_hourglasses || 0;
                  const enemyRerollCount = data.enemy_reroll_count || 0;

                  const cost = enemyRerollCount + 1;
                  const canReroll = enemyRerollCount < 3 && eternalHourglasses >= cost;

                  // Atualizar custo no bot√£o
                  const costElement = document.getElementById('enemy-rewrite-cost');
                  if (costElement) {
                      costElement.textContent = cost;
                  }

                  // Mostrar/ocultar divider
                  const divider = document.getElementById('enemy-rewrite-divider');
                  if (divider) {
                      divider.style.display = 'flex';

                      // Adicionar classe de disabled se n√£o puder reroll
                      const button = document.getElementById('enemy-rewrite-button');
                      if (button) {
                          if (canReroll) {
                              button.classList.remove('disabled');
                          } else {
                              button.classList.add('disabled');
                          }
                      }
                  }
              }
          })
          .catch(error => {
              console.error('Erro ao obter currencies:', error);
          });
  }

  async function executeEnemyRewrite() {
      const button = document.getElementById('enemy-rewrite-button');
      if (button && button.classList.contains('disabled')) {
          return;
      }

      button.classList.add('rewriting');

      // Tocar som
      const audio = new Audio('/static/game.data/sounds/rewrite.mp3');
      audio.volume = 0.5;
      audio.play().catch(err => console.log("Erro ao tocar som de rewrite:", err));

      try {
          const response = await fetch('/gamification/rewrite_enemies', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' }
          });

          const data = await response.json();

          if (data.success) {
              console.log("‚ú® Reroll de inimigos executado com sucesso!");

              // Animar fade out
              const grid = document.getElementById('enemy-grid');
              if (grid) {
                  grid.style.opacity = '0';
                  grid.style.transition = 'opacity 0.5s ease-out';

                  setTimeout(() => {
                      // Recarregar inimigos
                      fetch('/gamification/get_available_enemies')
                          .then(response => response.json())
                          .then(newData => {
                              if (newData.success) {
                                  // Atualizar dados globais
                                  window.currentBossData = newData;

                                  if (newData.is_boss_fight && newData.boss) {
                                      availableEnemies = [newData.boss];
                                      renderEnemyCards([newData.boss], false);
                                  } else {
                                      availableEnemies = newData.enemies;
                                      renderEnemyCards(newData.enemies, false);
                                  }

                                  // Atualizar divider
                                  updateEnemyRewriteDivider();

                                  // Fade in
                                  setTimeout(() => {
                                      grid.style.opacity = '1';
                                      button.classList.remove('rewriting');
                                  }, 50);
                              }
                          })
                          .catch(error => {
                              console.error('Erro ao recarregar inimigos:', error);
                              button.classList.remove('rewriting');
                          });
                  }, 500);
              }
          } else {
              addNotification(data.message || 'Erro ao reescrever escolhas');
              button.classList.remove('rewriting');
          }
      } catch (error) {
          console.error('Erro ao executar reroll:', error);
          addNotification('Erro ao reescrever escolhas');
          button.classList.remove('rewriting');
      }
  }

  // Event listener para o bot√£o de reroll de inimigos
  document.addEventListener('DOMContentLoaded', () => {
      const enemyRewriteBtn = document.getElementById('enemy-rewrite-button');
      if (enemyRewriteBtn) {
          enemyRewriteBtn.addEventListener('click', executeEnemyRewrite);
      }
  });

  // Mostrar pop-up automaticamente se for uma nova sess√£o de batalha
  // (essa fun√ß√£o ser√° chamada quando um boss for derrotado)
  function showNewBattleRewards() {
    // Esta fun√ß√£o ser√° chamada do sistema de batalha
    showBossSelection(true);
  }

  // Notification System
  document.addEventListener('DOMContentLoaded', function() {
      // Elements
      const notificationBell = document.getElementById('notificationBell');
      const notificationPanel = document.getElementById('notificationPanel');
      const notificationList = document.getElementById('notificationList');
      const notificationCount = document.getElementById('notificationCount');
      const clearNotificationsBtn = document.getElementById('clearNotifications');
      
      // Load notifications from localStorage
      let notifications = JSON.parse(localStorage.getItem('gameNotifications') || '[]');
      updateNotificationCount();
      
      // Toggle notification panel
      notificationBell.addEventListener('click', function() {
          const isVisible = notificationPanel.style.display === 'flex';
          notificationPanel.style.display = isVisible ? 'none' : 'flex';
          if (!isVisible) renderNotifications();
      });
      
      // Clear all notifications
      clearNotificationsBtn.addEventListener('click', function() {
          notifications = [];
          localStorage.setItem('gameNotifications', JSON.stringify(notifications));
          updateNotificationCount();
          renderNotifications();
      });
      
      // Close panel when clicking outside
      document.addEventListener('click', function(event) {
          if (!notificationBell.contains(event.target) && 
              !notificationPanel.contains(event.target) && 
              notificationPanel.style.display === 'flex') {
              notificationPanel.style.display = 'none';
          }
      });
      
      // Function to add a new notification
      window.addNotification = function(message) {
          const now = new Date();
          const timestamp = now.toLocaleTimeString() + ' ' + now.toLocaleDateString();
          notifications.unshift({ message, timestamp, read: false });
          if (notifications.length > 50) notifications.pop();
          localStorage.setItem('gameNotifications', JSON.stringify(notifications));
          updateNotificationCount();
          notificationBell.classList.add('notification-new');
          setTimeout(() => notificationBell.classList.remove('notification-new'), 500);
      };
      
      // Update notification count badge
      function updateNotificationCount() {
          const unread = notifications.filter(n => !n.read).length;
          notificationCount.textContent = unread;
          notificationCount.style.display = unread > 0 ? 'flex' : 'none';
      }
      
      // Render notifications in the panel
      function renderNotifications() {
          notificationList.innerHTML = '';
          if (!notifications.length) {
              const emptyEl = document.createElement('div');
              emptyEl.className = 'notification-empty';
              emptyEl.textContent = 'Nenhuma notifica√ß√£o.';
              notificationList.appendChild(emptyEl);
              return;
          }
          notifications.forEach((notif, i) => {
              const item = document.createElement('div');
              item.className = 'notification-item';
              const msg = document.createElement('div'); msg.textContent = notif.message;
              const time = document.createElement('div');
              time.style.fontSize = '10px';
              time.style.color = '#9ca3af';
              time.style.marginTop = '5px';
              time.textContent = notif.timestamp;
              item.append(msg, time);
              notificationList.appendChild(item);
              if (!notif.read) { notifications[i].read = true; }
          });
          localStorage.setItem('gameNotifications', JSON.stringify(notifications));
          updateNotificationCount();
      }
      
      // Process flash/gamification messages and data-notification attributes
      document.querySelectorAll('.alert-success, .alert-gamification, .alert-gamification-notification, [data-notification]').forEach(el => {
          const msg = el.textContent.trim() || el.getAttribute('data-notification');
          if (msg) addNotification(msg);
          el.remove();
      });
      
      // Process pending session notifications
      {% if session.get('pending_notifications') %}
        console.log("Notifica√ß√µes na sess√£o encontradas: {{ session.get('pending_notifications')|length }}");
        {% for notification in session.get('pending_notifications') %}
          addNotification("{{ notification|e }}");
        {% endfor %}
        {% set _ = session.pop('pending_notifications', None) %}
        updateNotificationCount();
      {% endif %}
  
      // Mover estas fun√ß√µes para DENTRO do DOMContentLoaded
      function showBossMilestoneMessage(enemiesDefeated) {
          const milestonePopup = document.createElement('div');
          milestonePopup.className = 'boss-milestone-popup';
          milestonePopup.innerHTML = `
              <div class="milestone-content">
                  <h2>üëë Boss Milestone!</h2>
                  <p>Voc√™ derrotou ${enemiesDefeated} inimigos!</p>
                  <p>Um boss especial apareceu!</p>
                  <button onclick="this.parentElement.parentElement.remove(); window.location.href='/gamification/battle'">
                      Enfrentar Boss
                  </button>
              </div>
          `;
          
          document.body.appendChild(milestonePopup);
      }
      
      // Event listener para bot√£o de batalha
      const battleBtn = document.querySelector('.battle-btn');
      if (battleBtn) {
        console.log("üîµ Event listener adicionado ao bot√£o batalha");
        
        battleBtn.addEventListener('click', function(e) {
          e.preventDefault();
          console.log("üî¥ CLIQUE INTERCEPTADO!");
          
          // Verificar se j√° tem inimigo selecionado
          fetch('/gamification/get_available_enemies')
            .then(response => response.json())
            .then(data => {
              console.log("üìä Dados dos inimigos:", data);
              console.log("üîç DEBUG selected_enemy_id:", data.selected_enemy_id);
              console.log("üîç DEBUG selected_boss_id:", data.selected_boss_id);
              console.log("üîç DEBUG is_boss_fight:", data.is_boss_fight);
              
              if (data.success) {
                if (data.selected_enemy_id || data.selected_boss_id) {
                  console.log("‚úÖ Inimigo/Boss j√° selecionado, indo para batalha");
                  window.location.href = '/gamification/battle';
                } else {
                  console.log("‚ö° Nenhum inimigo selecionado, mostrando pop-up");
                  showBossSelection(false);
                }
              }
            })
            .catch(error => {
              console.error('‚ùå Erro:', error);
              window.location.href = '/gamification/battle';
            });
        });
      } else {
        console.error("‚ùå Bot√£o .battle-btn n√£o encontrado!");
      }
      
      // Inicializar polling de vit√≥ria
      startVictoryPolling();

  });  // FIM CORRETO do DOMContentLoaded

  // Fun√ß√£o para ir para batalha com verifica√ß√£o de inimigo selecionado
  function goToBattle(event) {
      event.preventDefault();

      console.log("üéØ Tentando ir para batalha...");

      // Verificar se h√° inimigo selecionado
      fetch('/gamification/get_battle_data')
          .then(response => response.json())
          .then(data => {
              console.log("üìä Battle data:", data);

              if (data.success && (data.enemy || data.boss)) {
                  // H√° inimigo selecionado, pode ir para batalha
                  console.log("‚úÖ Inimigo selecionado, indo para batalha");
                  window.location.href = '/gamification/battle';
              } else {
                  // N√£o h√° inimigo selecionado, abrir pop-up de sele√ß√£o
                  console.log("‚ö†Ô∏è Nenhum inimigo selecionado, abrindo pop-up de sele√ß√£o");
                  openBossSelection();
              }
          })
          .catch(error => {
              console.error('‚ùå Erro ao verificar inimigo:', error);
              // Se houver erro, abrir pop-up de sele√ß√£o
              openBossSelection();
          });
  }

</script>

<!-- Pop-up de Sele√ß√£o de Boss -->
<div id="boss-selection-popup" class="ui-dialog" style="display:none">
  <div class="ui-panel boss-selection-modal">
    <h2 class="title">Escolha seu Pr√≥ximo Desafio</h2>
    <button class="close-popup-btn" onclick="closeBossSelection()">‚úï</button>
    <div class="enemy-grid" id="enemy-grid"></div>

    <!-- Rewrite Divider -->
    <div class="rewrite-divider" id="enemy-rewrite-divider" style="display: none;">
        <div class="rewrite-line"></div>
        <div class="rewrite-button" id="enemy-rewrite-button">
            <span class="rewrite-cost" id="enemy-rewrite-cost">1</span>
            <img src="{{ url_for('static', filename='game.data/hourglass_small.png') }}" alt="Ampulheta Eterna" class="rewrite-icon">
        </div>
        <div class="rewrite-line"></div>
    </div>
  </div>
</div>


{% endblock %}